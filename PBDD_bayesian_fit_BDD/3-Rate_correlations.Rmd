---
title: "Correlations between PBDD-simulated and BDD-inferred rates"
output: html_notebook
---

```{r}
library(ggplot2)
library(gridExtra)
library(reshape2)
library(lme4)
library(MuMIn)
```
# GLM model

```{r fig.width=15, fig.asp=0.3}
n_trees <- 100

# Function to plot correlations and record slopes
plot_and_record_slopes <- function(i) {
  # Read data
  file_base <- paste0("/Volumes/data/PBD_analog/PBDD_bayesian_fit_BDD/Rates/dataset", i)
  tipb_i <- read.table(paste0(file_base, "_tipb.csv"), sep="\t")[,1]
  tipc_i <- read.table(paste0(file_base, "_tipc.csv"), sep="\t")[,1]
  tipd_i <- read.table(paste0(file_base, "_tipd.csv"), sep="\t")[,1]
  
  seed_i <- gsub(".*seed|_tipλ.csv", "", list.files("/Volumes/data/PBD_analog/PBDD_bayesian_fit_BDD/Rates/", pattern=paste0("dataset",i,"-FitBDD_PBDDtrees_2000000iter_seed.*_tipλ.csv")))
  tipλ_i <- t(read.table(paste0(file_base, "-FitBDD_PBDDtrees_2000000iter_seed", seed_i, "_tipλ.csv"), sep="\t"))
  tipμ_i <- t(read.table(paste0(file_base, "-FitBDD_PBDDtrees_2000000iter_seed", seed_i, "_tipμ.csv"), sep="\t"))
  
  # Data preparation
  long_tipλ_i <- data.frame(Tip = factor(rep(1:nrow(tipλ_i), each = ncol(tipλ_i))),
                             PBDD.Bifurcation.Rate.b = rep(tipb_i, each = ncol(tipλ_i)),
                             PBDD.Completion.Rate.c = rep(tipc_i, each = ncol(tipλ_i)),
                             BDD.Speciation.Rate.λ = c(t(tipλ_i)))
  long_tipμ_i <- data.frame(Tip = factor(rep(1:nrow(tipμ_i), each = ncol(tipμ_i))),
                             PBDD.Death.Rate.d = rep(tipd_i, each = ncol(tipμ_i)),
                             BDD.Extinction.Rate.μ = c(t(tipμ_i)))

  # Fit models and extract coefficients
  model_λ_b <- lmer(log(BDD.Speciation.Rate.λ) ~ log(PBDD.Bifurcation.Rate.b) + (1|Tip), data = long_tipλ_i)
  model_λ_c <- lmer(log(BDD.Speciation.Rate.λ) ~ log(PBDD.Completion.Rate.c) + (1|Tip), data = long_tipλ_i)
  model_μ_d <- lmer(log(BDD.Extinction.Rate.μ) ~ log(PBDD.Death.Rate.d) + (1|Tip), data = long_tipμ_i)
  
  # Predict and create a new data frame for plotting
  # Include standard errors for confidence intervals
  pred_λ_b <- predict(model_λ_b, re.form = NA, se.fit = TRUE)
  pred_λ_c <- predict(model_λ_c, re.form = NA, se.fit = TRUE)
  pred_μ_d <- predict(model_μ_d, re.form = NA, se.fit = TRUE)

  # Calculating confidence intervals
  ci_level <- 1.96  # for approx. 95% CI
  long_tipλ_i$pred_λ_b <- pred_λ_b$fit
  long_tipλ_i$pred_λ_b_upper <- pred_λ_b$fit + ci_level * pred_λ_b$se.fit
  long_tipλ_i$pred_λ_b_lower <- pred_λ_b$fit - ci_level * pred_λ_b$se.fit
  long_tipλ_i$pred_λ_c <- pred_λ_c$fit
  long_tipλ_i$pred_λ_c_upper <- pred_λ_c$fit + ci_level * pred_λ_c$se.fit
  long_tipλ_i$pred_λ_c_lower <- pred_λ_c$fit - ci_level * pred_λ_c$se.fit
  long_tipμ_i$pred_μ_d <- pred_μ_d$fit
  long_tipμ_i$pred_μ_d_upper <- pred_μ_d$fit + ci_level * pred_μ_d$se.fit
  long_tipμ_i$pred_μ_d_lower <- pred_μ_d$fit - ci_level * pred_μ_d$se.fit

  # Plotting with predicted lines and confidence intervals
  p1 <- ggplot(long_tipλ_i, aes(x = PBDD.Bifurcation.Rate.b, y = BDD.Speciation.Rate.λ, color = Tip)) +
    geom_point(alpha = 0.2) +
    geom_line(aes(y = exp(pred_λ_b)), colour="grey40") +
    geom_ribbon(aes(ymin = exp(pred_λ_b_lower), ymax = exp(pred_λ_b_upper)), color="grey60", alpha = 0.2, fill = "grey") +
    scale_x_log10() +
    scale_y_log10() +
    ggtitle(paste0("Tip b vs λ correlation (tree ", i, ")")) +
    xlab("PBDD Bifurcation Rate b") + ylab("BDD Speciation Rate λ") +
    theme_minimal() + theme(legend.position = "none")

  p2 <- ggplot(long_tipλ_i, aes(x = PBDD.Completion.Rate.c, y = BDD.Speciation.Rate.λ, color = Tip)) +
    geom_point(alpha = 0.2) +
    geom_line(aes(y = exp(pred_λ_c)), colour="grey40") +
    geom_ribbon(aes(ymin = exp(pred_λ_c_lower), ymax = exp(pred_λ_c_upper)), color="grey60", alpha = 0.2, fill = "grey") +
    scale_x_log10() +
    scale_y_log10() +
    ggtitle(paste0("Tip c vs λ correlation (tree ", i, ")")) +
    xlab("PBDD Completion Rate c") + ylab("BDD Speciation Rate λ") +
    theme_minimal() + theme(legend.position = "none")

  p3 <- ggplot(long_tipμ_i, aes(x = PBDD.Death.Rate.d, y = BDD.Extinction.Rate.μ, color = Tip)) +
    geom_point(alpha = 0.2) +
    geom_line(aes(y = exp(pred_μ_d)), colour="grey40") +
    geom_ribbon(aes(ymin = exp(pred_μ_d_lower), ymax = exp(pred_μ_d_upper)), color="grey60", alpha = 0.2, fill = "grey") +
    scale_x_log10() +
    scale_y_log10() +
    ggtitle(paste0("Tip d vs μ correlation (tree ", i, ")")) +
    xlab("PBDD Death Rate d") + ylab("BDD Extinction Rate μ") +
    theme_minimal() + theme(legend.position = "none")

  grid.arrange(p1, p2, p3, nrow = 1)

  # Extract slopes and confidence intervals
  slope_λ_b <- fixef(model_λ_b)["log(PBDD.Bifurcation.Rate.b)"]
  slope_λ_c <- fixef(model_λ_c)["log(PBDD.Completion.Rate.c)"]
  slope_μ_d <- fixef(model_μ_d)["log(PBDD.Death.Rate.d)"]

  ci_λ_b <- confint(model_λ_b, level = 0.95)["log(PBDD.Bifurcation.Rate.b)",]
  ci_λ_c <- confint(model_λ_c, level = 0.95)["log(PBDD.Completion.Rate.c)",]
  ci_μ_d <- confint(model_μ_d, level = 0.95)["log(PBDD.Death.Rate.d)",]

  # Calculate R-squared values
  r2_λ_b <- r.squaredGLMM(model_λ_b)
  r2_λ_c <- r.squaredGLMM(model_λ_c)
  r2_μ_d <- r.squaredGLMM(model_μ_d)

  # Store slopes and CIs
  slopes_and_ci <- data.frame(
    Tree = i,
    Tips = nrow(tipλ_i),
    Slope_b = slope_λ_b, LowerCI_b = ci_λ_b[1], UpperCI_b = ci_λ_b[2],
    Slope_c = slope_λ_c, LowerCI_c = ci_λ_c[1], UpperCI_c = ci_λ_c[2],
    Slope_d = slope_μ_d, LowerCI_d = ci_μ_d[1], UpperCI_d = ci_μ_d[2],
    R2m_b = r2_λ_b[,1], R2c_b = r2_λ_b[,2],
    R2m_c = r2_λ_c[,1], R2c_c = r2_λ_c[,2],
    R2m_d = r2_μ_d[,1], R2c_d = r2_μ_d[,2]
  )

  return(slopes_and_ci)
}

# Run for all trees and bind results
#plot_and_record_slopes(3)
slopes_and_ci <- do.call(rbind, lapply(2:n_trees, plot_and_record_slopes))
```

```{r fig.width=15, fig.asp=0.3}
# Plotting the slopes against the number of tips with legends
p1 <- ggplot(slopes_and_ci, aes(x = Tips)) +
  geom_pointrange(aes(y = Slope_b, ymin = LowerCI_b, ymax = UpperCI_b, color = "Slope (95%CI)"), alpha=0.3) +
  geom_line(aes(y = Slope_b, group = 1, color = "Slope (95%CI)"), alpha=0.3) +
  geom_point(aes(y = R2m_b, color = "Marginal R2")) +
  geom_line(aes(y = R2m_b, group = 2, color = "Marginal R2")) +
  geom_point(aes(y = R2c_b, color = "Conditional R2")) +
  geom_line(aes(y = R2c_b, group = 2, color = "Conditional R2")) +
  geom_hline(yintercept = c(0,1), lty = c(1, 2)) +
  scale_x_log10() + ylim(-2.5,2) +
  labs(title = "PBDD log-b regression against BDD log-λ",
       x = "Number of Tips",
       y = "Correlation") +
  scale_color_manual(values = c("Slope (95%CI)" = "darkblue", "Marginal R2" = "darkgreen", "Conditional R2" = "darkolivegreen3")) +
  theme(legend.position.inside=c(0.5, 0.07), legend.direction="horizontal") + 
  guides(color = guide_legend(title = "Legend", position="inside"))

p2 <- ggplot(slopes_and_ci, aes(x = Tips)) +
  geom_pointrange(aes(y = Slope_c, ymin = LowerCI_c, ymax = UpperCI_c, color = "Slope (95%CI)"), alpha=0.3) +
  geom_line(aes(y = Slope_c, group = 1, color = "Slope (95%CI)"), alpha=0.3) +
  geom_point(aes(y = R2m_c, color = "Marginal R2")) +
  geom_line(aes(y = R2m_c, group = 2, color = "Marginal R2")) +
  geom_point(aes(y = R2c_c, color = "Conditional R2")) +
  geom_line(aes(y = R2c_c, group = 2, color = "Conditional R2")) +
  geom_hline(yintercept = c(0,1), lty = c(1, 2)) +
  scale_x_log10() + ylim(-2.5,2) +
  labs(title = "PBDD log-c regression against BDD log-λ",
       x = "Number of Tips",
       y = "Correlation") +
  scale_color_manual(values = c("Slope (95%CI)" = "darkblue", "Marginal R2" = "darkgreen", "Conditional R2" = "darkolivegreen3")) +
  theme(legend.position.inside=c(0.5, 0.07), legend.direction="horizontal") + 
  guides(color = guide_legend(title = "Legend", position="inside"))

p3 <- ggplot(slopes_and_ci, aes(x = Tips)) +
  geom_pointrange(aes(y = Slope_d, ymin = LowerCI_d, ymax = UpperCI_d, color = "Slope (95%CI)"), alpha=0.3) +
  geom_line(aes(y = Slope_d, group = 1, color = "Slope (95%CI)"), alpha=0.3) +
  geom_point(aes(y = R2m_d, color = "Marginal R2")) +
  geom_line(aes(y = R2m_d, group = 2, color = "Marginal R2")) +
  geom_point(aes(y = R2c_d, color = "Conditional R2")) +
  geom_line(aes(y = R2c_d, group = 2, color = "Conditional R2")) +
  geom_hline(yintercept = c(0,1), lty = c(1, 2)) +
  scale_x_log10() + ylim(-2.5,2) +
  labs(title = "PBDD log-d regression against BDD log-μ",
       x = "Number of Tips",
       y = "Correlation") +
  scale_color_manual(values = c("Slope (95%CI)" = "darkblue", "Marginal R2" = "darkgreen", "Conditional R2" = "darkolivegreen3")) +
  theme(legend.position.inside=c(0.5, 0.07), legend.direction="horizontal") + 
  guides(color = guide_legend(title = "Legend", position="inside"))

grid.arrange(p1, p2, p3, nrow = 1)
```

# Bayesian Hierarchical Model

Load the package in R:

```{r}
library(ggplot2)
library(gridExtra)
library(rstan)
```

## Fitting and plotting

```{r}
# Define Stan model
stan_model_code <- 
"data {
    int<lower=0> N;                  // number of observations
    int<lower=0> J;                  // number of tips
    vector[N] y;                     // response variable (log-transformed BDD rate)
    vector[N] x;                     // predictor variable (log-transformed PBDD rate)
    int<lower=1, upper=J> tip_id[N]; // tip index for each observation
  }
  
  parameters {
    real alpha;                      // intercept
    real beta;                       // slope
    real<lower=0> sigma_y;           // residual std dev
    real<lower=0> sigma_tip;         // random effect std dev
    vector[J] u;                     // random effects for tips
  }
  
  model {
    // Priors
    alpha ~ normal(0, 10);
    beta ~ normal(0, 10);
    sigma_y ~ exponential(1);
    sigma_tip ~ exponential(1);
    u ~ normal(0, sigma_tip);
    
    // Likelihood
    for (n in 1:N)
      y[n] ~ normal(alpha + beta * x[n] + u[tip_id[n]], sigma_y);
  }"

stan_model_regression <- stan_model(model_code=stan_model_code)
```

```{r fig.width=15, fig.asp=0.3}
rstan_fit <- function(x_data, y_data){
  # Prepare data for Stan
  stan_data <- list(
    N = nrow(y_data) * ncol(y_data),
    J = nrow(y_data),
    y = as.vector(t(y_data)),
    x = rep(x_data, each = ncol(y_data)),
    tip_id = rep(1:nrow(y_data), each = ncol(y_data))
  )

  # Fit the model
  fit <- sampling(stan_model_regression, data = stan_data, iter = 3000, chains = 3, seed = 123)
  #fit <- sampling(stan_model_regression, data = stan_data, iter = 1000, chains = 3, seed = 123)
  fit_result <- list(fit=fit, data=stan_data)
  
  return(fit_result)
}

bayesian_regression <- function(i) {
  # Read data
  file_base <- paste0("/Volumes/data/PBD_analog/PBDD_bayesian_fit_BDD/Rates/dataset", i)
  tipb_i <- read.table(paste0(file_base, "_tipb.csv"), sep="\t")[,1]
  tipc_i <- read.table(paste0(file_base, "_tipc.csv"), sep="\t")[,1]
  tipd_i <- read.table(paste0(file_base, "_tipd.csv"), sep="\t")[,1]
  
  # Read MCMC samples
  seed_i <- gsub(".*seed|_tipλ.csv", "", list.files("/Volumes/data/PBD_analog/PBDD_bayesian_fit_BDD/Rates/", pattern=paste0("dataset",i,"-FitBDD_PBDDtrees_2000000iter_seed.*_tipλ.csv")))
  tipλ_i <- t(read.table(paste0(file_base, "-FitBDD_PBDDtrees_2000000iter_seed", seed_i, "_tipλ.csv"), sep="\t"))
  tipμ_i <- t(read.table(paste0(file_base, "-FitBDD_PBDDtrees_2000000iter_seed", seed_i, "_tipμ.csv"), sep="\t"))
  
  # Fit Bayesian hierarchical model
  fitb <- rstan_fit(x_data=log(tipb_i), y_data=log(tipλ_i))
  fitc <- rstan_fit(x_data=log(tipc_i), y_data=log(tipλ_i))
  fitd <- rstan_fit(x_data=log(tipd_i), y_data=log(tipμ_i))
  
  fits <- list(b = fitb, c = fitc, d = fitd)
  return(fits)
}

# Example of running the function
fits <- lapply(1:n_trees, bayesian_regression)
#fits <- lapply(c(2,5), bayesian_regression)

save(fits, file="/Volumes/data/PBD_analog/PBDD_bayesian_fit_BDD/Results/Correlation_fits.Rdata")
```

```{r}
extract_posterior_values <- function(fit_result){
  # Extract posterior samples
  posterior_samples <- extract(fit_result$fit)
  alpha_post <- posterior_samples$alpha
  beta_post <- posterior_samples$beta
  u_post <- posterior_samples$u

  # Calculate posterior medians and CIs for alpha and beta
  posterior_values <- list(
    alpha_median = median(alpha_post),
    alpha_Q005 = quantile(alpha_post, 0.005),
    alpha_Q995 = quantile(alpha_post, 0.995),
    beta_median  = median(beta_post),
    beta_Q005 = quantile(beta_post, 0.005),
    beta_Q995 = quantile(beta_post, 0.995),
    Ntips = fit_result$data$J
  )

  # Calculate predictions for each tip and overall
  posterior_predict <- array(dim = c(length(fit_result$data$x), length(alpha_post)))
  posterior_predict_marginal <- array(dim = c(length(fit_result$data$x), length(alpha_post)))
  for (j in 1:fit_result$data$J) {
    tip_indices <- which(fit_result$data$tip_id == j)
    for (i in 1:length(alpha_post)) {
      posterior_predict[tip_indices, i] <- alpha_post[i] + beta_post[i] * fit_result$data$x[tip_indices] + u_post[i, j]
      posterior_predict_marginal[tip_indices, i] <- alpha_post[i] + beta_post[i] * fit_result$data$x[tip_indices]
    }
  }

  # Calculate 99% Credible Interval and median predictions
  posterior_values$pred_y_Q005 <- apply(posterior_predict_marginal, 1, quantile, probs=0.005)
  posterior_values$pred_y_Q995 <- apply(posterior_predict_marginal, 1, quantile, probs=0.995)
  posterior_values$pred_y_median <- apply(posterior_predict_marginal, 1, median)

  # Calculate (conditional and marginal) pseudo-R² values
  # Variance for all samples
  total_var <- var(fit_result$data$y)
  resid_var_c <- var(fit_result$data$y-rowMeans(posterior_predict))
  resid_var_m <- var(fit_result$data$y-rowMeans(posterior_predict_marginal))
  posterior_values$R2c <- 1 - resid_var_c/total_var
  posterior_values$R2m <- 1 - resid_var_m/total_var
  # Variance for means a posteriori
  #y_mean <- apply(matrix(fit_result$data$y, ncol=fit_result$data$J), 2, mean)
  #posterior_predict_mean <- colMeans(matrix(rowMeans(posterior_predict), ncol=fit_result$data$J))
  #posterior_predict_marginal_mean <- colMeans(matrix(rowMeans(posterior_predict_marginal), ncol=fit_result$data$J))
  #total_var_mean <- var(y_mean)
  #resid_var_mean_c <- var(y_mean-posterior_predict_mean)
  #resid_var_mean_m <- var(y_mean-posterior_predict_marginal_mean)
  #posterior_values$R2c_mean <- 1 - resid_var_mean_c/total_var_mean
  #posterior_values$R2m_mean <- 1 - resid_var_mean_m/total_var_mean

  return(posterior_values)
}

posterior_values <- lapply(fits, function(fit)list(b=extract_posterior_values(fit$b), c=extract_posterior_values(fit$c), d=extract_posterior_values(fit$d)))
lapply(posterior_values[[1]], names)
```

```{r fig.width=15, fig.asp=0.3}
plot_regression <- function(data, posterior_values, x_rate, y_rate){
  
  plot_data <- data.frame(
    Tip = factor(data$tip_id),
    BifurcationRate = exp(data$x),
    SpeciationRate = exp(data$y),
    PredictedRate = exp(posterior_values$pred_y_median),
    LowerCI = exp(posterior_values$pred_y_Q005),
    UpperCI = exp(posterior_values$pred_y_Q995)
  )
  
  # Plotting with credible intervals
  p <- ggplot(plot_data, aes(x = BifurcationRate, y = SpeciationRate, color = Tip)) +
    geom_point(alpha = 0.2) +  # observed data points
    geom_line(aes(y = PredictedRate), color = "black", linetype = "dashed") +
    geom_ribbon(aes(ymin = LowerCI, ymax = UpperCI), color="grey60", alpha = 0.4, fill = "grey") +  # adding confidence intervals
    scale_x_log10() +  # since x is log-transformed
    scale_y_log10() +  # since y is log-transformed
    labs(title = paste0(y_rate," vs. ",x_rate," tip-rate correspondance"),
         x = paste0("PBDD ",x_rate," Rate"),
         y = paste0("Inferred BDD ",y_rate," Rate")) +
    theme_minimal() +
    theme(legend.position = "none")
  
  return (p)
}

for (i in 1:length(posterior_values)){
  pb <- plot_regression(fits[[i]]$b$data, posterior_values[[i]]$b, x_rate="Bifurcation", y_rate="Speciation")
  pc <- plot_regression(fits[[i]]$c$data, posterior_values[[i]]$c, x_rate="Completion", y_rate="Speciation")
  pd <- plot_regression(fits[[i]]$d$data, posterior_values[[i]]$d, x_rate="Death", y_rate="Extinction")
  
  grid.arrange(pb, pc, pd, nrow = 1)
}
```

## Correlations for increasing tree size

```{r fig.width=15, fig.asp=0.3}
# Function to create plots from posterior values
plot_results <- function(posterior_values) {
  plots <- lapply(c("b","c","d"), function(rate){
    # Assuming 'posterior_values' is a list of lists containing all the necessary statistics
    df <- data.frame(
      Tips = unlist(lapply(posterior_values, function(x) x[[rate]]$Ntips)),
      Slope = unlist(lapply(posterior_values, function(x) x[[rate]]$beta_median)),
      LowerCI = unlist(lapply(posterior_values, function(x) x[[rate]]$beta_Q005)),
      UpperCI = unlist(lapply(posterior_values, function(x) x[[rate]]$beta_Q995)),
      R2m = unlist(lapply(posterior_values, function(x) x[[rate]]$R2m)),
      R2c = unlist(lapply(posterior_values, function(x) x[[rate]]$R2c))
    )
    
    ylim_min <- -2.5
    ylim_max <- 2
    p <- ggplot(df, aes(x = Tips)) +
      geom_pointrange(aes(y = Slope, ymin = sapply(LowerCI,max,ylim_min), ymax = sapply(UpperCI,min,ylim_max), color = "Slope (99%CI)"), alpha=0.3) +
      geom_line(aes(y = Slope, group = 1, color = "Slope (99%CI)"), alpha=0.3) +
      geom_point(aes(y = R2m, color = "Marginal R2")) +
      geom_line(aes(y = R2m, group = 2, color = "Marginal R2")) +
      geom_point(aes(y = R2c, color = "Conditional R2")) +
      geom_line(aes(y = R2c, group = 2, color = "Conditional R2")) +
      geom_hline(yintercept = c(0,1), lty = c(1, 2)) +
      labs(title = paste0("PBDD log-",rate," regression against BDD log-", ifelse(rate=="d","μ","λ")),
           x = "Number of Tips",
           y = "Correlation") +
      scale_color_manual(values = c("Slope (99%CI)" = "darkblue", "Marginal R2" = "darkgreen", "Conditional R2" = "darkolivegreen3")) +
      ylim(ylim_min,ylim_max) + scale_x_log10() +
      theme(legend.position.inside=c(0.5, 0.07), legend.direction="horizontal") + 
      guides(color = guide_legend(title = "Legend", position="inside"))
  })
  grid.arrange(grobs=plots, nrow = 1)
}

# Call the plotting function with results
plot_results(posterior_values)
```

```{r fig.width=15, fig.asp=0.3}
# Function to create plots from posterior values
plot_results <- function(posterior_values) {
  plots <- lapply(c("b","c","d"), function(rate){
    # Assuming 'posterior_values' is a list of lists containing all the necessary statistics
    df <- data.frame(
      Tips = unlist(lapply(posterior_values, function(x) x[[rate]]$Ntips)),
      Slope = unlist(lapply(posterior_values, function(x) x[[rate]]$beta_median)),
      LowerCI = unlist(lapply(posterior_values, function(x) x[[rate]]$beta_Q005)),
      UpperCI = unlist(lapply(posterior_values, function(x) x[[rate]]$beta_Q995)),
      R2m = unlist(lapply(posterior_values, function(x) x[[rate]]$R2m)),
      R2c = unlist(lapply(posterior_values, function(x) x[[rate]]$R2c))
    )
    
    ylim_min <- -2.5
    ylim_max <- 2
    p <- ggplot(df, aes(x = Tips)) +
      geom_pointrange(aes(y = Slope, ymin = sapply(LowerCI,max,ylim_min), ymax = sapply(UpperCI,min,ylim_max), color = "Slope (99%CI)"), alpha=0.3) +
      geom_line(aes(y = Slope, group = 1, color = "Slope (99%CI)"), alpha=0.3) +
      geom_point(aes(y = R2m/R2c, color = "Marginal R2 / Conditional R2")) +
      geom_line(aes(y = R2m/R2c, group = 2, color = "Marginal R2 / Conditional R2")) +
      geom_hline(yintercept = c(0,1), lty = c(1, 2)) +
      labs(title = paste0("PBDD log-",rate," regression against BDD log-", ifelse(rate=="d","μ","λ")),
           x = "Number of Tips",
           y = "Correlation") +
      scale_color_manual(values = c("Slope (99%CI)" = "darkblue", "Marginal R2 / Conditional R2" = "darkred")) +
      ylim(ylim_min,ylim_max) + scale_x_log10() +
      theme(legend.position.inside=c(0.5, 0.07), legend.direction="horizontal") + 
      guides(color = guide_legend(title = "Legend", position="inside"))
  })
  grid.arrange(grobs=plots, nrow = 1)
}

# Call the plotting function with results
plot_results(posterior_values)
```

## Correlations for increasing mean completion rate

```{r fig.width=15, fig.asp=0.3}
# Function to create plots from posterior values
plot_results <- function(posterior_values, fits) {
  plots <- lapply(c("b","c","d"), function(rate){
    # Assuming 'posterior_values' is a list of lists containing all the necessary statistics
    df <- data.frame(
      MeanLambda = unlist(lapply(fits, function(fit_result) mean(fit_result$c$data$x))),
      Tips = unlist(lapply(posterior_values, function(x) x[[rate]]$Ntips)),
      Slope = unlist(lapply(posterior_values, function(x) x[[rate]]$beta_median)),
      LowerCI = unlist(lapply(posterior_values, function(x) x[[rate]]$beta_Q005)),
      UpperCI = unlist(lapply(posterior_values, function(x) x[[rate]]$beta_Q995)),
      R2m = unlist(lapply(posterior_values, function(x) x[[rate]]$R2m)),
      R2c = unlist(lapply(posterior_values, function(x) x[[rate]]$R2c))
    )
    
    ylim_min <- -2.5
    ylim_max <- 2
    p <- ggplot(df, aes(x = exp(MeanLambda))) +
      geom_pointrange(aes(y = Slope, ymin = sapply(LowerCI,max,ylim_min), ymax = sapply(UpperCI,min,ylim_max), color = "Slope (99%CI)", size=log10(Tips)), alpha=0.3, pch=20) +
      scale_size_continuous(range = c(0.1,2)) +
      geom_line(aes(y = Slope, group = 1, color = "Slope (99%CI)"), alpha=0.3) +
      geom_point(aes(y = R2m/R2c, color = "Marginal R2 / Conditional R2", size=log10(Tips)), pch=19) +
      geom_line(aes(y = R2m/R2c, group = 2, color = "Marginal R2 / Conditional R2")) +
      geom_hline(yintercept = c(0,1), lty = c(1, 2)) +
      labs(title = paste0("PBDD log-",rate," regression against BDD log-", ifelse(rate=="d","μ","λ")),
           x = "Mean Completion Rate",
           y = "Correlation") +
      scale_color_manual(values = c("Slope (99%CI)" = "darkblue", "Marginal R2 / Conditional R2" = "darkred")) +
      ylim(ylim_min,ylim_max) + scale_x_log10() +
      theme(legend.position.inside=c(0.5, 0.07), legend.direction="horizontal") + 
      guides(color = guide_legend(title = "Legend", position="inside"), size='none')
  })
  grid.arrange(grobs=plots, nrow = 1)
}

# Call the plotting function with results
plot_results(posterior_values, fits)
```

```{r fig.width=15, fig.asp=0.3}
# Function to create plots from posterior values
plot_results <- function(posterior_values, fits) {
  plots <- lapply(c("b","c","d"), function(rate){
    # Assuming 'posterior_values' is a list of lists containing all the necessary statistics
    df <- data.frame(
      MeanLambda = unlist(lapply(fits, function(fit_result) mean(fit_result$c$data$x))),
      Tips = unlist(lapply(posterior_values, function(x) x[[rate]]$Ntips)),
      Slope = unlist(lapply(posterior_values, function(x) x[[rate]]$beta_median)),
      LowerCI = unlist(lapply(posterior_values, function(x) x[[rate]]$beta_Q005)),
      UpperCI = unlist(lapply(posterior_values, function(x) x[[rate]]$beta_Q995)),
      R2m = unlist(lapply(posterior_values, function(x) x[[rate]]$R2m)),
      R2c = unlist(lapply(posterior_values, function(x) x[[rate]]$R2c))
    )
    
    ylim_min <- -2.5
    ylim_max <- 2
    p <- ggplot(df[df$Tips>30,], aes(x = exp(MeanLambda))) +
      geom_pointrange(aes(y = Slope, ymin = sapply(LowerCI,max,ylim_min), ymax = sapply(UpperCI,min,ylim_max), color = "Slope (99%CI)", size=log10(Tips)), alpha=0.3, pch=20) +
      scale_size_continuous(range = c(0.1,2)) +
      geom_line(aes(y = Slope, group = 1, color = "Slope (99%CI)"), alpha=0.3) +
      geom_point(aes(y = R2m/R2c, color = "Marginal R2 / Conditional R2", size=log10(Tips)), pch=19) +
      geom_line(aes(y = R2m/R2c, group = 2, color = "Marginal R2 / Conditional R2")) +
      geom_hline(yintercept = c(0,1), lty = c(1, 2)) +
      labs(title = paste0("PBDD log-",rate," regression against BDD log-", ifelse(rate=="d","μ","λ")),
           x = "Mean Completion Rate",
           y = "Correlation") +
      scale_color_manual(values = c("Slope (99%CI)" = "darkblue", "Marginal R2 / Conditional R2" = "darkred")) +
      ylim(ylim_min,ylim_max) + scale_x_log10() +
      theme(legend.position.inside=c(0.5, 0.07), legend.direction="horizontal") + 
      guides(color = guide_legend(title = "Legend", position="inside"), size='none')
  })
  grid.arrange(grobs=plots, nrow = 1)
}

# Call the plotting function with results
plot_results(posterior_values, fits)
```

